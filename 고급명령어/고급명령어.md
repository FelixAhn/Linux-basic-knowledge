## 고급 명령어
```bash
CUT : 간결한 문접으로 파일에서 문자열 필드를 뽑아내는 명령

SED : 텍스트 입력 스트림을 받아 출력을 제어할 수 있는 명령

AWK : sed 기능 + 변수 / 함수 / 연산자를 사용하여 필요한 데이터를 제어할 수 있는 프로그램이 가능한 명령
```


## SED
```bash 
sed 옵션 문자열_스크립트 파일명

-옵션
    -e : 입력을 처리하는 하나의 처리 명령을 의미
         여러 번 저장하여 여러 번의 처리가 가능
    -f file : 사전에 명령을 추가한 파일을 지정하여 명령을 수행
    -n : 각 명령의 결과를 화면에 출력하지 않고 print 명령을 대기
    -r : 확장된 정규표현식을 사용

- 문자열 처리 명령어
[텍스트라인-범위]/p : 출력 (print)
[텍스트라인-범위]/d : 출력 (delete)
s/소스패턴/결과패턴/ : 한 줄에서 처음 나타나는 소스패턴을 결과패턴으로 치환 (substitute)
[텍스트라인-범위]s/소스패턴/결과패턴/ : 지정한 범위에서 처음 나타나는 소스패턴을 결과패턴으로 치환 (substitute)
[텍스트라인-범위]y/소스패턴/결과패턴/ : 지정한 범위에서 소스패턴을 결과패턴으로 바꿈, 문자 수가 같아야 함(transform)
명령어처리_스크립트/g : 명령어처리 스크립트의 모든 소스패턴을 결과패턴으로 변경 (global)
```


### 예시
```bash
# 예시1
echo "이것은 테스트" | sed 's/테스트/test/'
이것은 test

data.txt
========================
1.이것은 테스트
2.이것은 테스트
3.이것은 테스트
4.이것은 테스트
5.이것은 테스트
========================

# 예시2
sed 's/테스트/test/' data.txt
1.이것은 test
2.이것은 test
3.이것은 test
4.이것은 test
5.이것은 test

# 예시3
sed '3,5s/테스트/sed test/' data.txt
1.이것은 테스트
2.이것은 테스트
3.이것은 sed test
4.이것은 sed test
5.이것은 sed test

# 예시4
sed '3,5d' data.txt
1.이것은 테스트
2.이것은 테스트

# 예시5
sed 's/테스트/sed test/w data2.txt' data.txt
1.이것은 sed test
2.이것은 sed test
3.이것은 sed test
4.이것은 sed test
5.이것은 sed test

cat data2.txt
1.이것은 sed test
2.이것은 sed test
3.이것은 sed test
4.이것은 sed test
5.이것은 sed test

# 예시6
sed -e 's/테스트/test/; s/이것은/this/' dat.txt
1.this test
2.this test
3.this test
4.this test
5.this test

# 예시7
sed -n 's/테스트/test' data.txt
sed -n 's/테스트/test/p' data.txt
1.이것은 test
2.이것은 test
3.이것은 test
4.이것은 test
5.이것은 test

# 예시8
test.sed
========================
s/테스트/sed test/
========================

sed -f test.sed data.txt
1.이것은 sed test
2.이것은 sed test
3.이것은 sed test
4.이것은 sed test
5.이것은 sed test
```

## 정규표현식
```bash
텍스트의 패턴을 특수문자 등을 사용하여 표현한 것

A* : A다음에 0개 이상의 문자를 매칭 (A Aa Abc)
A? : A다음에 1개의 문자를 매칭 (Aa Ab Ac)
^A : A로 시작하는 문자열 (Abcde Avoid Attack)
A$ : A로 끝나는 문자열 (A bA cdgdA)
A|B : A 또는 B가 있음을 의미 (c[A|B]f : cAf cBf)
[a-z] : a부터 z까지 알파벳의 범위를 매칭 (a b c ... z)


# 예제
ls -1 a*
ls -1 | grep ^a
find . -type -f -iname "t*"
find . -iname "txt?"
find . -iname "t[x|z]t"
ls -al txt[0-9]
ls -al txt[0-9][0-9]
sed -n '/^3/p' data.txt
sed -n '/c$/p' data.txt
```
