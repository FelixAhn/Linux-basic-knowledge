## 고급 명령어
```bash
CUT : 간결한 문접으로 파일에서 문자열 필드를 뽑아내는 명령

SED : 텍스트 입력 스트림을 받아 출력을 제어할 수 있는 명령

AWK : sed 기능 + 변수 / 함수 / 연산자를 사용하여 필요한 데이터를 제어할 수 있는 프로그램이 가능한 명령
```


## SED
```bash 
sed 옵션 문자열_스크립트 파일명

-옵션
    -e : 입력을 처리하는 하나의 처리 명령을 의미
         여러 번 저장하여 여러 번의 처리가 가능
    -f file : 사전에 명령을 추가한 파일을 지정하여 명령을 수행
    -n : 각 명령의 결과를 화면에 출력하지 않고 print 명령을 대기
    -r : 확장된 정규표현식을 사용

- 문자열 처리 명령어
[텍스트라인-범위]/p : 출력 (print)
[텍스트라인-범위]/d : 출력 (delete)
s/소스패턴/결과패턴/ : 한 줄에서 처음 나타나는 소스패턴을 결과패턴으로 치환 (substitute)
[텍스트라인-범위]s/소스패턴/결과패턴/ : 지정한 범위에서 처음 나타나는 소스패턴을 결과패턴으로 치환 (substitute)
[텍스트라인-범위]y/소스패턴/결과패턴/ : 지정한 범위에서 소스패턴을 결과패턴으로 바꿈, 문자 수가 같아야 함(transform)
명령어처리_스크립트/g : 명령어처리 스크립트의 모든 소스패턴을 결과패턴으로 변경 (global)
```


### 예시
```bash
# 예시1
echo "이것은 테스트" | sed 's/테스트/test/'
이것은 test

data.txt
========================
1.이것은 테스트
2.이것은 테스트
3.이것은 테스트
4.이것은 테스트
5.이것은 테스트
========================

# 예시2
sed 's/테스트/test/' data.txt
1.이것은 test
2.이것은 test
3.이것은 test
4.이것은 test
5.이것은 test

# 예시3
sed '3,5s/테스트/sed test/' data.txt
1.이것은 테스트
2.이것은 테스트
3.이것은 sed test
4.이것은 sed test
5.이것은 sed test

# 예시4
sed '3,5d' data.txt
1.이것은 테스트
2.이것은 테스트

# 예시5
sed 's/테스트/sed test/w data2.txt' data.txt
1.이것은 sed test
2.이것은 sed test
3.이것은 sed test
4.이것은 sed test
5.이것은 sed test

cat data2.txt
1.이것은 sed test
2.이것은 sed test
3.이것은 sed test
4.이것은 sed test
5.이것은 sed test

# 예시6
sed -e 's/테스트/test/; s/이것은/this/' dat.txt
1.this test
2.this test
3.this test
4.this test
5.this test

# 예시7
sed -n 's/테스트/test' data.txt
sed -n 's/테스트/test/p' data.txt
1.이것은 test
2.이것은 test
3.이것은 test
4.이것은 test
5.이것은 test

# 예시8
test.sed
========================
s/테스트/sed test/
========================

sed -f test.sed data.txt
1.이것은 sed test
2.이것은 sed test
3.이것은 sed test
4.이것은 sed test
5.이것은 sed test
```

## 정규표현식
```bash
텍스트의 패턴을 특수문자 등을 사용하여 표현한 것

A* : A다음에 0개 이상의 문자를 매칭 (A Aa Abc)
A? : A다음에 1개의 문자를 매칭 (Aa Ab Ac)
^A : A로 시작하는 문자열 (Abcde Avoid Attack)
A$ : A로 끝나는 문자열 (A bA cdgdA)
A|B : A 또는 B가 있음을 의미 (c[A|B]f : cAf cBf)
[a-z] : a부터 z까지 알파벳의 범위를 매칭 (a b c ... z)


# 예제
ls -1 a*
ls -1 | grep ^a
find . -type -f -iname "t*"
find . -iname "txt?"
find . -iname "t[x|z]t"
ls -al txt[0-9]
ls -al txt[0-9][0-9]
sed -n '/^3/p' data.txt
sed -n '/c$/p' data.txt
```

## AWK
```bash
sed 기능 + 변수 / 함수 / 연산자를 사용하여 필요한 데이터를 제어할 수 있는 커맨드

-F 필드구분자 : 필드를 구분하기 위한 구분자를 지정
-f 파일이름 : awk프로그램이 읽어드일 파일 이름을 지정
-변수 =변수값 : awk프로그램에서 사용할 변수를 지정
```

### 예제1
```bash
txt13
==================
aaa 111 zzz
bbb 222 xxx
ccc 333 yyy
ddd 444 qqq
eee 555 ddd
==================

awk '{print $1}' txt13
aaa
bbb
ccc
ddd 
eee

awk '{print $2}' txt13
111
222
333
444
555

awk '{print $3}' txt13
zzz
xxx
yyy
qqq
ddd

awk '{print $1}' txt13 | grep ccc
ccc

awk '/ccc/ {print $3}' txt13
ccc

grep 111 txt13 | awk '{print $3}'
zzz

awk '/111/ {print $3}' txt13
zzz
```

### 예제2
```bash
colon_txt13
==================
aaa:111:zzz
bbb:222:xxx
ccc:333:yyy
ddd:444:qqq
eee:555:ddd
==================

awk -F: '{print $1}' colon_txt13
aaa
bbb
ccc
ddd
eee

awk -F: '{print $2}' colon_txt13
111
222
333
444
555

awk -F: '{print $3}' colon_txt13
zzz
xxx
yyy
qqq
ddd

awk -F: '{print $1}' /etc/passwd
서버 유저명 출력

uptime | awk '{print $8, $9, $10}'
0.00, 0.00, 0.00

uptime | awk '{print $8, $9, $10}' | awk -F, '{print $1, $2, $3}' 
0.00 0.00 0.00

uptime | awk -Faverage: '{print %2}'
0.00, 0.00, 0.00
```

### 예제3
```bash
df_chk.awk
====================================
{
    gsub(/%/,"")
    PER=0, MNT=""
    if ( NF == 6 ) PER=$5
    if ( PER > 30 ) MNT=$6
    printf "%d%\t%s\n",PER,MNT
}
====================================

df | awk -f df_chk.awk
0%
0%
0%
3%
35%     /
0%

df | awk -f df-chk.awk | grep \/
35%     /
```
